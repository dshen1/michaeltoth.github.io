Title: Creating the Percolation Visualization
Date: 2014-10-01 21:50
Authors: Michael Toth
Modified: 2014-10-01 21:50
Category: Projects
Tags: Javascript, Canvas, Projects
Slug: Percolation
Summary: In this post I will discuss the background and formulation of the
percolation visualization page and the details of my implementation. This is
the first non-trivial Javascript application I've created, and later in the
post I will discuss some of the biggest challenges I faced and things I learned
along the way.  I hope to provide a good introduction to percolation
theory and the union find algorithm in particular.

In this post I will discuss the background and formulation of the
percolation visualization page and the details of my implementation. This is
the first non-trivial Javascript application I've created, and later in the
post I will discuss some of the biggest challenges I faced and things I learned
along the way.  I hope to provide a good introduction to percolation
theory and the union find algorithm in particular.

##Background

I first became interested in the percolation problem and the union find
algorithm while enrolled in Robert Sedgwick's and Kevin Wayne's
[Algorithms](https://www.coursera.org/course/algs4partI "Coursera -
Algorithms") class on Coursera.  In the class I implemented a solution in Java,
and afterward I thought that it would be an interesting challenge to port that
solution to Javascript and create a visualization on my website.  For the web
version I use Javascript for all of the calculations,  and I use the HTML canvas 
element to draw the visualization to the screen.

#### Connectivity and the Union Find Algorithm

A connectivity problem seeks to determine, given a directed graph of sites,
whether two particular sites are connected via any path.  For example:

<Show a graphic here of connected sites>

For a small set of sites such as the one above, a brute force approach of
checking a site and all of its neighbors to see whether such a path exists
would work fine.  As the number of sites grows large however, this algorithm
does not scale, and we need a better solution.  Instead of thinking of
the grid of sites as a directed graph, we can convey the same information as a
grouping of components as seen in the image below.  Now, determining whether any
two sites are connected is as simple as checking whether they are both members of 
the same component.

<Show a graphic here of connected components>

The Union Find data structure, sometimes called a disjoint set data structure or
a merge-find set, allows for high performance operations on a component grouping 
as described above.  The Union Find data structure keeps track of a set of 
elements partitioned into a number of disjoint subsets (components).  A union 
find structure of size N is initialized with N disjoint components, and the data 
structure supports two main operations:

Find: Return the id of the component to which the given site is a member
Union: Connect two sites by combining their two components into a single
component with the same id

A new Union Find data structure of size N is initialized with N distinct
components.  Calls to the Union operation create a tree of components such
that when two sets are combined, the members of one set will point to those
of the other set.  The find operation then traverses to the top of the tree
to find the root member, which I have labeled as the "id" of the component.
In this implementation, the find operation takes time proportional to the 
depth of the tree.  A naive implementation of the union operation could allow
trees to potentially become very deep, which would slow the performance of this
algorithm.  Instead, if we modify the union function such that we always append
the smaller component to the larger component, we reduce the maximum depth of 
the tree and ensure that the algorithm takes O(nlg(n)) in the worst case.  

*Abbreviated Proof*:  
- Note: lg = log base 2  
- Given a node x, its depth in the tree will increase by 1 when its tree T1 
is merged into another tree T2.  
- When this happens, the size of x's tree will at least double, because our 
union operation requires size(T2) > size(T1) for T1 to point to T2.  
- Through any number of union operations, the size of x's tree can double at
most lg(N) times [ lg(2^N) = N ], the total number of nodes.  
- *Therefore*: Traversals take O(nlg(n)) in the worst case  

Below I have included my complete Javascript code for the Union Find data 
structure.  This code is essentially the same as the Java code presented in 
the Coursera class mentioned above.  In this implementation I include two new
operations: a connected operation that returns true if two sites are connected 
and a count variable that returns the number of unique components.

```javascript
// Union find implementation for efficient checking of percolation
function WeightedQuickUnionUF(N) {
    
    // Constructor
    var id = [];
    var sz = []; 
    for (var i = 0; i < N; i++) {
        id[i] = i; // id[i] = parent of i
        sz[i] = 1; // sz[i] = number of objects in subtree rooted at i
    }

    // Returns the number of components, which starts at N
    this.count = N;

    // Returns the component id for the component containing site
    this.find = function(p) {
        while (p != id[p]) {
            p = id[p];
        }
        return p;
    }

    // Returns true if two elements are part of the same component
    this.connected = function(p, q) {
        return this.find(p) === this.find(q);
    }

    // Connects the components of two elements
    this.union = function(p, q) {
        var rootP = this.find(p);
        var rootQ = this.find(q);
        if (rootP === rootQ) { return; }
        
        // make smaller root point to large one
        if (sz[rootP] < sz[rootQ]) {
            id[rootP] = rootQ; sz[rootQ] += sz[rootP];
        } else {
            id[rootQ] = rootP; sz[rootP] += sz[rootQ];
        }
        this.count--;
    }
} 
```

####Percolation

The percolation problem takes a grid of sites that can be set to either open
or closed.  If we imagine that water is flowing across the top of the grid, an
open site will become full with water when it can be connected by other open
sites in an unbroken path to the top of the grid.  The system percolates when
an open site on the bottom of the grid can be connected by other open sites in
an unbroken path to the top of the grid, such that water will flow freely
through the system. This can be best determined using the Union Find algorithm
above, by checking to see whether the two sites are connected using the
connected function.

For a large square grid of sites, there exists a percolation threshold
probability p such that if we open fewer than p percent of the sites the
system will not percolate, and if we open greater than p percent of the sites
the system will percolate.  An exact expression for the percolation threshold
of a square grid is currently unknown, but we can use experimentation to
approximate the value as 0.592746.  That is, for a large square grid, the
system should first percolate after we have opened 59.2746% of the sites.
    
Note that the Union Find implementation is efficient for determining whether 2
sites are connected, but this still requires N^2 time if we need to check
whether any of the N sites in the top row are connected to any of the N sites
in the bottom row.  To address this, we create two "virtual sites" on the top
and bottom of the grid which we automatically connect sites on the top and
bottom rows as they open.  Then, to determine whether the system percolates we
can simply check whether the top and bottom virtual sites are connected using
the efficient union find algorithm.
    
##Challenges

####Creating the Visualization
Initially I had thought to create the grid of sites using a grid of divs which
I would then be able to color according to their status, similar to my
previous [Mondrian Painting Project](../Mondrian/mondrian.html "Michael Toth -
Piet Mondrian Painting").  I wanted to support the ability to change the size
of the grid however, and a large number of divs seemed unnecessarily
cumbersome.  I did some searching on [Codepen.io](http://codepen.io "Codepen")
for ideas, and found some examples using the HTML5 canvas element, which was
exactly what I needed.  I enjoyed experimenting and figuring out what worked
here.

####Converting Implementation from Java
I had trouble initially with porting the Java code to Javascript.  In Java,
the well-defined class relationships were clear to me, but I did not at first
understand how to implement similar in Javascript.  I later found that
Javascript functions could have similar functionality to Java classes, and was
able to use this knowledge to port my code.

####Bug when performing multiple runs
My first implementation suffered from a bug where if I reran the simulation,
the first percolation run would continue to run in the background, causing
issues with the display and text output to the screen.  I knew that the
solution would be to clear the interval on rerun, but I did not know how I
could access the id of setInterval, an instance variable of the previous
simulatePercolation class instance, when creating a new instance of the
percolation class.  After some experimentation, I found that if I declared the
interval variable in the head of my HTML, I could assign it to setInterval
when running simulatePercolation, which would eliminate the possibility of
duplicate intervals running simultaneously.  

####Iteratively Opening Sites and Drawing
Initially I implemented the process of opening sites and drawing to the screen
using a while loop, but this was not ideal.  I could run the entire
percolation simulation and then draw to the screen, but if I tried drawing to
the screen after each site was opened, the browser would freeze.  I wanted to
be able to show each site being opened successively, so I needed to find a way
to delay the opening of new sites until I could draw to the screen.  I ended
up accomplishing this through the use of Javascript's setInterval method.
Ultimately, I added 3 options for timing.  Show code:

```javascript
// Runs a while loop until system percolates then outputs to screen
function outputInstantly() {
    while (!perc.percolates()) {
        openRandom();
        count++;
    }
    drawPerc.drawGrid();
}

// If no delay, draw instantly.  Otherwise, draw with setInterval and delay
if (delay === 0) {
    outputInstantly();
} else {
    // Repeatedly call checkPerc to open one-by-one until system percolates 
    interval = setInterval(checkPerc, delay);
    interval();
}
```


