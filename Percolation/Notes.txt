Creating the Percolation Visualization Page

I first learned about the percolation problem and the union find algorithm through Robert Sedgwick's and Kevin Wayne's Algorithm's class on Coursera:  https://www.coursera.org/course/algs4partI.  In that class we implemented a solution in Java, and I thought that it would be an interesting challenge to port that solution to Javascript and create a visualization on my website, so I did.  I built the application with Javascript and used the HTML canvas element to draw the visualization.  This is the first non-trivial Javascript application that I have created, and I've documented the biggest challenges I faced with the implementation later in this post.

--Background--

-Percolation-
The percolation problem takes a grid of sites that can be set to either open or closed.  If we imagine that water is flowing across the top of the grid, an open site will become full with water when it can be connected by other open sites in an unbroken path to the top of the grid.  The system percolates when an open site on the bottom of the grid can be connected by other open sites in an unbroken path to the top of the grid, such that water will flow freely through the system.  

For a large square grid of sites, there exists a percolation threshold probability p such that if we open fewer than p percent of the sites the system will not percolate, and if we open greater than p percent of the sites the system will percolate.  An exact expression for the percolation threshold of a square grid is currently unknown, but we can use experimentation to approximate the value as 0.592746.  That is, for a large square grid, the system should first percolate after we have opened 59.2746% of the sites.

-Union Find Algorithm-
Testing for percolation requires checking whether there exists a connection between two sites on the top and bottom of the grid.  A brute-force solution does not scale to large grid sizes, so we need a more efficient implementation.
	
The Union Find data structure keeps track of a set of elements partitioned into a number of disjoint subsets (components).  A union find structure of size N is initialized with N disjoint components.  The data structure supports two main operations:

Find: Return the id of the component to which the given site is a member
Union: Connect two sites by combining their two components into a single component with the same id

The find function takes constant time.  By modifying the union function such that we always append the smaller component to the larger component, we reduce the maximum depth of the tree and ensure that the algorithm takes O(n*log(n)) in the worst case.  // Include proof based on doubling

Code for Union Find implementation in Javascript:

<here>
	
Note that the Union Find implementation is efficient for determining whether 2 sites are connected, but this still requires N^2 time if we need to check whether any of the N sites in the top row are connected to any of the N sites in the bottom row.  To address this, we create two "virtual sites" on the top and bottom of the grid which we automatically connect sites on the top and bottom rows as they open.  Then, to determine whether the system percolates we can simply check whether the top and bottom virtual sites are connected using the efficient union find algorithm.
	
-- Challenges --

Initially I had thought to create the grid of sites using a grid of divs which I would then be able to color according to their status, similar to my previous Mondrian project implementation (link to page).  I wanted to support a variable size of the grid however, and a large number of divs seemed unnecessarily cumbersome.  I did some searching on Codepen.io for ideas, and found some implementations using the HTML5 canvas element.  I ultimately decided to use the canvas element for the implementation, which was perfect for what I needed.  I enjoyed experimenting and figuring out what worked here.

I had trouble initially with porting the implementation from Java.  In Java, the well-defined class relationships were clear to me, but I did not at first understand how to implement these in Javascript.  I later found that Javascript functions could have similar functionality.

Initially I implemented the process of opening sites and drawing to the screen using a while loop, but this was not ideal.  I could run the entire percolation simulation and then draw to the screen, but if I tried drawing to the screen after each site was opened, the browser would freeze.  I wanted to be able to show each site being opened successively, so I needed to find a way to delay the opening of new sites until I could draw to the screen.  I ended up accomplishing this through the use of Javascript's setInterval method.  Ultimately, I added 3 options for timing.  Show code:

<here>

My first implementation suffered from a bug where if I reran the simulation, the first percolation run would continue to run in the background, causing issues with the display and text output to the screen.  I knew that the solution would be to clear the interval on rerun, but I did not know how I could access the id of setInterval, an instance variable of the previous simulatePercolation class instance, when creating a new instance of the percolation class.  After some experimentation, I found that if I declared the interval variable in the head of my HTML, I could assign it to setInterval when running simulatePercolation, which would eliminate the possibility of duplicate intervals running simultaneously.  
